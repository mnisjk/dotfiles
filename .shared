# start shared

uname -a | fgrep 'Darwin' >/dev/null
RESULT=$?
if [ $RESULT -eq 0 ]; then
    . ~/bin/.colors-mac
    alias __git_ps1="git branch 2>/dev/null | grep '*' | sed 's/* \(.*\)/(\1)/'"
    #echo "Mac"
else
    . ~/bin/.colors
    #echo "Linux"
fi

alias ll='ls -alFh'
alias la='ls -A'
alias l='ls -CF'
PS1="${Blue}(\A)${Color_Off} \u@\h ${Cyan}\W ${Purple}`__git_ps1` ${Color_Off}\$ "
. ~/bin/z.sh

# git related stuff

export SVN_EDITOR=vi
export GIT_EDITOR=vi
git config color.ui true 
alias pull='git pull origin master'
alias co='git checkout'
alias st='git status'
alias di='git diff'
alias commit='git commit -a -m'
alias pushm='git push origin master'
branch(){
    if [ $# = 1 ]; then
        git pull origin master
        git branch $1
        git checkout $1
    else         
        echo "Usage: $0 <branch name>"
    fi                                                                                                                                                                
}

push(){
    curBranch=`git branch | grep ^\* | sed 's/* //g'`
    if [ "$curBranch" == "master" ]; then
        echo "You are on master dummy!"
    else
        status=`git status | fgrep "Changed but not updated"`
        if [ "$status" == "" ]; then
            #NO LONGER MERGING MASTER IN BEFORE PUSHING
            #git pull origin master 2>/dev/null
            #if [ $? -eq 0 ]; then
            git push origin $curBranch
            if [ $? -eq 0 ]; then
                echo "Copy for pull requst: $curBranch"
            else
                echo "Error pushing origin"
            fi
            #else
            #    echo "You have merge conflicts. Fix them."
            #fi
        else
            echo "Commit your changes before you push"
        fi
    fi
}


#log stuff

mnisjk(){         
    tail -n 5001 /var/log/syslog | grep -B5 -A5 --color=always "\[smartscan\]\|\[mnisjk\]\|PHP Fatal error\|PHP Parse error\|PHP Warning\|Error processing\|assert\|alrt\|warn\|eror"
    echo ---------------------
    tail -n 50 -f /var/log/syslog | grep -i -B5 -A5 --color=always "\[smartscan\]\|\[mnisjk\]\|PHP Fatal error\|PHP Parse error\|PHP Warning\|Error processing\|assert\|alrt\|warn\|eror"
}

# wrap_alias takes three arguments:
# $1: The name of the alias
# $2: The command used in the alias
# $3: The arguments in the alias all in one string
# Generate a wrapper completion function (completer) for an alias
# based on the command and the given arguments, if there is a
# completer for the command, and set the wrapper as the completer for
# the alias.
function wrap_alias() {
  [[ "$#" == 3 ]] || return 1

  local alias_name="$1"
  local aliased_command="$2"
  local alias_arguments="$3"
  local num_alias_arguments=$(echo "$alias_arguments" | wc -w)

  # The completion currently being used for the aliased command.
  local completion=$(complete -p $aliased_command 2> /dev/null)

  # Only a completer based on a function can be wrapped so look for -F
  # in the current completion. This check will also catch commands
  # with no completer for which $completion will be empty.
  echo $completion | grep -q -- -F || return 0

  local namespace=alias_completion::

  # Extract the name of the completion function from a string that
  # looks like: something -F function_name something
  # First strip the beginning of the string up to the function name by
  # removing "* -F " from the front.
  local completion_function=${completion##* -F }
  # Then strip " *" from the end, leaving only the function name.
  completion_function=${completion_function%% *}

  # Try to prevent an infinite loop by not wrapping a function
  # generated by this function. This can happen when the user runs
  # this twice for an alias like ls='ls --color=auto' or alias l='ls'
  # and alias ls='l foo'
  [[ "${completion_function#$namespace}" != $completion_function ]] && return 0

  local wrapper_name="${namespace}${alias_name}"

  eval "
function ${wrapper_name}() {
  let \"COMP_CWORD+=$num_alias_arguments\"
  args=( \"${alias_arguments}\" )
  COMP_WORDS=( $aliased_command \${args[@]} \${COMP_WORDS[@]:1} )
  $completion_function
  }
"

  # To create the new completion we use the old one with two
  # replacements:
  # 1) Replace the function with the wrapper.
  local new_completion=${completion/-F * /-F $wrapper_name }
  # 2) Replace the command being completed with the alias.
  new_completion="${new_completion% *} $alias_name"

  eval "$new_completion"
}

# For each defined alias, extract the necessary elements and use them
# to call wrap_alias.
eval "$(alias -p | sed -e 's/alias \([^=][^=]*\)='\''\([^ ][^ ]*\) *\(.*\)'\''/wrap_alias \1 \2 '\''\3'\'' /')"

unset wrap_alias
